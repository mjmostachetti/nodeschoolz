// Generated by CoffeeScript 1.7.1
(function() {
  var Backbone, Clients, Console, File, FileList, FoldList, Projects, PseudoList, STYLUS_FUNC_FILE, StateList, basename, callClient, fs, getFileLocation, log, pathIsAllowed, relativeURL, requirejs, stylus, watcher, _, _ref, _ref1, _ref2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require("fs");

  basename = require("path").basename;

  Backbone = require("backbone");

  requirejs = require("requirejs");

  _ = require("underscore")._;

  callClient = require("./clients").callClient;

  _ref = require("./data"), Clients = _ref.Clients, Projects = _ref.Projects;

  _ref1 = require("./utils"), getFileLocation = _ref1.getFileLocation, relativeURL = _ref1.relativeURL, pathIsAllowed = _ref1.pathIsAllowed;

  _ref2 = requirejs("./../public/lib/models"), FileList = _ref2.FileList, File = _ref2.File, StateList = _ref2.StateList, FoldList = _ref2.FoldList, PseudoList = _ref2.PseudoList;

  watcher = require("./filewatcher").watcher;

  stylus = require("./stylus");

  log = require('./log');

  STYLUS_FUNC_FILE = require("path").dirname(require.resolve('stylus')) + '/lib/functions/index.styl';

  Console = (function() {
    function Console(project) {
      this.project = project;
      _.bindAll(this, "_onFileAdd", "_onFileRemove", "_onFileChange", "disableConsole", "callAPI", "callClient", "onBackup");
      log.info({
        project: this.project.id
      }, 'Create console');
      this.imports = {};
      this.clientId = 0;
      Backbone.connector.connect(new FoldList(null, {
        backend: "folds-" + project.id
      }));
      Backbone.connector.connect(new PseudoList(null, {
        backend: "pseudos-" + project.id
      }));
      Backbone.connector.connect(this.states = new StateList(null, {
        backend: "state-" + this.project.id
      }));
      this.states.create({}, {
        wait: true
      });
      this.files = new FileList(null, {
        backend: "files-" + this.project.id
      });
      Backbone.connector.connect(this.files);
      this.files.bind("add", this._onFileAdd);
      this.files.bind("remove", this._onFileRemove);
      this.files.bind("updated", this._onFileChange);
      this._scanDirectoryForFiles();
      _.each(this.project.getClients(), this._onClientAdd, this);
      this.project.bind("clients:add", this._onClientAdd, this);
    }

    Console.prototype._onClientAdd = function(client) {
      log.debug({
        client: client.id
      }, 'Client added');
      this.setClientFiles(client.id, client.get("css"));
      client.bind("change:css", this._onClientChange, this);
      client.bind("change:connected", this._onClientChange, this);
      return client.bind("remove", this._onClientRemove, this);
    };

    Console.prototype._onClientChange = function(client) {
      if (client.get('connected')) {
        return this.setClientFiles(client.id, client.get("css"));
      } else {
        return client.published = {};
      }
    };

    Console.prototype._onClientRemove = function(client) {
      return this.setClientFiles(client.id, []);
    };

    Console.prototype._scanDirectoryForFiles = function() {
      var files;
      files = this.project.get("files");
      return _.each(files, (function(_this) {
        return function(_arg) {
          var newfiles, path, stylusout, type, url;
          url = _arg.url, path = _arg.path, type = _arg.type, newfiles = _arg.newfiles, stylusout = _arg.stylusout;
          if (!pathIsAllowed(path)) {
            return log.error({
              path: path
            }, 'Access denied to scan files');
          }
          return fs.readdir(path, function(err, flist) {
            if (err) {
              return log.error({
                path: path,
                err: err
              }, 'Failed to scan directory for files');
            }
            return flist.forEach(function(file) {
              var fname, fpath, furl;
              if (!(file[0] !== '.' && file.match((type === "stylus" ? /\.styl$/i : /\.css$/i)))) {
                return;
              }
              fpath = path + file;
              if (url.slice(-1)[0] !== "/") {
                url += "/";
              }
              furl = url + file.replace(/\.styl$/i, ".css");
              fname = _.last(file.split(/[\\\/]/));
              file = _this.files.find(function(f) {
                return furl === f.get("url");
              });
              if (file) {
                return file.save({
                  keepalive: true
                });
              } else {
                return fs.stat(fpath, function(err, stat) {
                  return _this.files.create({
                    url: furl,
                    name: fname,
                    fsize: stat.size,
                    mtime: stat.mtime,
                    type: type,
                    keepalive: true
                  }, {
                    wait: true
                  });
                });
              }
            });
          });
        };
      })(this));
    };

    Console.prototype.listenFile = function(file) {
      watcher.watch(file.srcpath, (function(_this) {
        return function() {
          return _this.files.trigger("updated", file);
        };
      })(this));
      this.files.trigger("updated", file, true);
      return log.debug({
        project: this.project.id,
        url: file.get("url"),
        path: file.srcpath
      }, 'Listen on file');
    };

    Console.prototype._onFileAdd = function(file) {
      var url;
      if (this._added == null) {
        this._added = {};
      }
      if (this._added[file.id]) {
        return;
      }
      this._added[file.id] = 1;
      url = file.get("url");
      if (url.match(/^#local/)) {
        file.srcpath = file.get("path");
        return this.listenFile(file);
      } else {
        return getFileLocation(this.project, url, (function(_this) {
          return function(err, srcpath, csspath) {
            if (!err) {
              file.srcpath = srcpath;
              file.csspath = csspath;
              return _this.listenFile(file);
            }
          };
        })(this));
      }
    };

    Console.prototype._onFileRemove = function(file) {
      delete this._added[file.id];
      watcher.unwatch(file.srcpath);
      return log.debug({
        project: this.project.id,
        path: file.srcpath
      }, 'Deactivate file');
    };

    Console.prototype._onFileChange = function(f, isInitial) {
      log.debug({
        path: f.srcpath
      }, 'Updated file');
      this.publish(f);
      return fs.stat(f.srcpath, (function(_this) {
        return function(err, stat) {
          var file, imports, parent, _ref3, _ref4, _results;
          if (!isInitial) {
            f.save({
              mtime: stat.mtime,
              fsize: stat.size
            });
          }
          _ref3 = _this.imports;
          _results = [];
          for (parent in _ref3) {
            imports = _ref3[parent];
            if (_ref4 = f.srcpath, __indexOf.call(imports, _ref4) >= 0) {
              file = _this.files.find(function(ff) {
                return ff.srcpath === parent && ff.get('mtime') < f.get('mtime');
              });
              if (file) {
                _results.push(_this.publish(file));
              } else {
                _results.push(void 0);
              }
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this));
    };

    Console.prototype.destroy = function() {
      log.info({
        project: this.project.id
      }, 'Destory console');
      this.files.each((function(_this) {
        return function(file) {
          return _this._onFileRemove(file);
        };
      })(this));
      if (this.socket) {
        return this.deactivateSocket(this.socket);
      }
    };

    Console.prototype.pathToUrl = function(path) {
      var files, fpath, newfiles, stylusout, type, url, _i, _len, _ref3;
      files = this.project.get("files");
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        _ref3 = files[_i], url = _ref3.url, fpath = _ref3.path, type = _ref3.type, newfiles = _ref3.newfiles, stylusout = _ref3.stylusout;
        if ((path.indexOf(fpath)) === 0) {
          return url + path.substr(fpath.length);
        }
      }
      return null;
    };

    Console.prototype.publish = function(file, clients) {
      var url;
      if (!file.csspath) {
        return;
      }
      if (clients == null) {
        clients = file.get('clients');
      }
      url = file.get('url');
      if (!file.srcpath) {
        return log.error({
          path: file.srcpath
        }, 'Could not publish');
      }
      if (!pathIsAllowed(file.srcpath)) {
        return;
      }
      return fs.readFile(file.srcpath, "utf8", (function(_this) {
        return function(err, data) {
          if (err) {
            return log.error({
              path: file.srcpath,
              err: err
            }, 'Failed to read source file');
          }
          if (data.charCodeAt(0) === 65279) {
            data = data.substr(1);
          }
          if (file.get('type') === 'stylus') {
            log.info({
              file: file.srcpath
            }, 'Render Stylus file');
            return stylus.renderStylus(file.srcpath, data, function(err, css, imports) {
              if (err) {
                return log.warn({
                  path: file.srcpath,
                  err: err
                }, 'Failed to render Stylus.');
              }
              _this.stylusSetFileImports(file.srcpath, imports);
              _this.publishData(file, css, clients);
              log.debug({
                csspath: file.csspath,
                clients: clients.length
              }, 'Writing compiled CSS file:');
              return fs.writeFile(file.csspath, css);
            });
          } else {
            return _this.publishData(file, data, clients);
          }
        };
      })(this));
    };

    Console.prototype.publishData = function(file, data, clients) {
      var url;
      if (clients == null) {
        clients = file.get('clients');
      }
      url = file.get('url');
      if (data.charCodeAt(0) === 65279) {
        data = data.substr(1);
      }
      return _.each(clients, function(clientId) {
        var client;
        client = Clients.get(clientId);
        if (!client) {
          return log.warn({
            client: clientId
          }, "Client lost without cleanup");
        }
        callClient(clientId, "setStyles", {
          url: url,
          data: data
        });
        return log.info({
          client: clientId,
          uid: client.cid,
          url: url,
          length: data.length
        }, "Sending new styles");
      });
    };

    Console.prototype.publishFile = function(file, clients) {
      if (clients == null) {
        clients = file.get('clients');
      }
      if (!file.csspath) {
        return log.error({
          file: file.csspath
        }, 'Could not publish file');
      }
      return fs.readFile(file.csspath, "utf8", (function(_this) {
        return function(err, data) {
          if (err) {
            return log.error({
              file: file.csspath,
              err: err
            }, 'Failed to read file');
          }
          return _this.publishData(file, data, clients);
        };
      })(this));
    };

    Console.prototype.addClientToFile = function(file, clientId) {
      var client, clients, url;
      log.debug({
        file: file.get('url'),
        client: clientId
      }, 'addClientToFile');
      clients = _.clone(file.get("clients"));
      if (__indexOf.call(clients, clientId) < 0) {
        clients.push(clientId);
        file.save({
          clients: clients
        });
      }
      client = Clients.get(clientId);
      if (client.published == null) {
        client.published = {};
      }
      url = file.get('url');
      if (!client.published[url]) {
        this.publishFile(file, [clientId]);
        return client.published[url] = true;
      }
    };

    Console.prototype.setClientFiles = function(clientId, css) {
      var flist;
      flist = this.files;
      log.debug({
        files: css,
        client: clientId
      }, 'Set client files');
      return _.each(css, (function(_this) {
        return function(cssfile) {
          var file;
          file = flist.find(function(f) {
            return cssfile === f.get("url");
          });
          if (file) {
            _this.addClientToFile(file, clientId);
          } else {
            getFileLocation(_this.project, cssfile, function(err, srcpath) {
              var name, type;
              if (err) {
                return;
              }
              log.debug({
                file: cssfile,
                err: err,
                srcpath: srcpath
              }, 'Client got file location');
              file = flist.find(function(f) {
                return cssfile === f.get("url");
              });
              if (file) {
                return _this.addClientToFile(file, clientId);
              }
              name = _.last(srcpath.split(/[\\\/]/));
              type = srcpath.match(/\.styl$/i) ? 'stylus' : 'css';
              return fs.stat(srcpath, function(err, stat) {
                return flist.create({
                  url: cssfile,
                  name: name,
                  fsize: stat.size,
                  mtime: stat.mtime,
                  clients: [clientId],
                  type: type
                }, {
                  wait: true
                });
              });
            });
          }
          return flist.each(function(file) {
            var clients, keepalive, url;
            url = file.get("url");
            clients = file.get("clients");
            keepalive = file.get("keepalive");
            if (__indexOf.call(clients, clientId) >= 0 && __indexOf.call(css, url) < 0) {
              clients = _.without(clients, clientId);
              if (!keepalive && clients.length === 0) {
                return file.destroy();
              } else {
                return file.save({
                  clients: clients
                });
              }
            }
          });
        };
      })(this));
    };

    Console.prototype.activateSocket = function(socket) {
      this.socket = socket;
      socket.on('callAPI', this.callAPI);
      socket.on('callclient', this.callClient);
      socket.on('deactivate', this.disableConsole);
      return socket.on('disconnect', this.disableConsole);
    };

    Console.prototype.deactivateSocket = function(socket) {
      socket.on('backup', this.onBackup);
      socket.emit('deactivate');
      socket.removeListener('callAPI', this.callAPI);
      socket.removeListener('callclient', this.callClient);
      socket.removeListener('deactivate', this.disableConsole);
      socket.removeListener('disconnect', this.disableConsole);
      return this.socket = null;
    };

    Console.prototype.onBackup = function(data) {
      var _ref3;
      return (_ref3 = this.socket) != null ? _ref3.emit('startupdata', data) : void 0;
    };

    Console.prototype.disableConsole = function() {
      if (this.clientId) {
        callClient(this.clientId, "deactivate");
        this.clientId = 0;
      }
      if (this.socket) {
        return this.deactivateSocket(this.socket);
      }
    };

    Console.prototype.callAPI = function(name, params, cb) {
      var _name;
      return typeof this[_name = "api" + name] === "function" ? this[_name](params, cb) : void 0;
    };

    Console.prototype.callClient = function(clientId) {
      if (this.clientId === clientId) {
        return callClient.apply(null, arguments);
      }
    };

    Console.prototype.activateConsole = function(socket, clientId) {
      var _ref3;
      log.info({
        client: clientId,
        old: this.clientId
      }, 'Activate console');
      if (socket.id !== ((_ref3 = this.socket) != null ? _ref3.id : void 0)) {
        if (this.socket) {
          this.deactivateSocket(this.socket);
        }
        this.activateSocket(socket);
      }
      if (this.clientId && this.clientId !== clientId) {
        callClient(this.clientId, "deactivate");
      }
      if (clientId) {
        callClient(clientId, "activate");
      }
      this.clientId = clientId;
      return socket.emit('activate');
    };

    Console.prototype.onClientMessage = function(name, params) {
      var _ref3;
      return (_ref3 = this.socket) != null ? _ref3.emit('clientmessage', name, params) : void 0;
    };

    Console.prototype.apiGetImgList = function(params, cb) {
      var base, files, fpath, i, key, parts, stylusout, type, url, urlparts, _i, _len, _ref3;
      parts = params.url.split("/");
      base = parts.slice(0, -1);
      key = parts.slice(-1)[0];
      files = this.project.get("files");
      if (files) {
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          _ref3 = files[_i], url = _ref3.url, fpath = _ref3.path, stylusout = _ref3.stylusout, type = _ref3.type;
          if (type === 'stylus') {
            fpath = stylusout;
          }
          if ('/' !== _.last(fpath)) {
            fpath += '/';
          }
          urlparts = url.split("/");
          if (urlparts[2] === parts[2]) {
            fpath = fpath.split("/");
            i = 0;
            while (true) {
              if (urlparts[i] !== base[i]) {
                break;
              }
              i++;
            }
            fpath = fpath.slice(0, -urlparts.length + i);
            fpath = fpath.concat(base.slice(i));
            fpath = fpath.join("/");
            fs.stat(fpath, function(err, stats) {
              if (err || stats.isFile()) {
                return cb(null);
              }
              return fs.readdir(fpath, function(err, files) {
                if (err) {
                  return cb(null);
                }
                files = _.map(files, function(file) {
                  var st;
                  if ((file[0] === ".") || (0 !== file.toLowerCase().indexOf(key))) {
                    return false;
                  }
                  try {
                    st = fs.statSync(fpath + "/" + file);
                  } catch (_error) {
                    err = _error;
                    return false;
                  }
                  if (st.isDirectory()) {
                    return file + "/";
                  } else {
                    if (file.match(/\.(png|jpe?g|gif)$/i)) {
                      return file;
                    } else {
                      return false;
                    }
                  }
                });
                return cb(_.compact(files.sort()));
              });
            });
            return;
          }
        }
      }
    };

    Console.prototype.apiPublishChanges = function(params, cb) {
      var file;
      log.debug('API called publish changes');
      file = this.files.find(function(f) {
        return params.url === f.get("url");
      });
      if (file) {
        this.publishData(file, params.data);
      }
      return cb();
    };

    Console.prototype.apiGetFileData = function(params, cb) {
      var file;
      file = this.files.find(function(f) {
        return params.url === f.get("url");
      });
      if (!(file != null ? file.srcpath : void 0)) {
        return;
      }
      log.info({
        path: file.srcpath,
        url: file.get('url')
      }, "Reading file");
      if (file) {
        return fs.readFile(file.srcpath, "utf8", function(err, data) {
          if (err) {
            return log.error({
              file: file.srcpath,
              err: err
            }, 'Failed to read file');
          }
          return cb({
            data: data,
            name: basename(file.srcpath)
          });
        });
      } else {
        return cb({
          data: null
        });
      }
    };

    Console.prototype.apiSetFileData = function(params, cb) {
      var file;
      file = this.files.find(function(f) {
        return params.url === f.get("url");
      });
      if (!((file != null ? file.srcpath : void 0) && pathIsAllowed(file.srcpath))) {
        return;
      }
      log.info({
        file: file.srcpath,
        length: params.data.length
      }, 'Writing file');
      return fs.writeFile(file.srcpath, params.data, function(err) {
        if (err) {
          log.error({
            file: file.srcpath,
            err: err
          }, 'Failed to write file');
        }
        return cb(err);
      });
    };

    Console.prototype.apiPublishSaved = function(params, cb) {
      var file;
      file = this.files.find(function(f) {
        return params.url === f.get("url");
      });
      return this.publishFile(file);
    };

    Console.prototype.stylusSetFileImports = function(file, imports) {
      var nibpath;
      if (!imports) {
        return delete this.imports[file];
      }
      nibpath = require("nib").path;
      return this.imports[file] = _.compact(_.map(imports, (function(_this) {
        return function(item) {
          var furl, name, path, url;
          if (item.path === STYLUS_FUNC_FILE) {
            return;
          }
          path = item.path;
          url = _this.pathToUrl(path);
          file = _this.files.find(function(f) {
            return f.srcpath === path;
          });
          if (!file) {
            furl = 0 === path.indexOf(nibpath) ? path.slice(nibpath.length + 1) : Math.random() * 1e6 | 0;
            name = _.last(path.split(/[\\\/]/));
            fs.stat(path, function(err, stat) {
              return _this.files.create({
                fsize: stat.size,
                mtime: stat.mtime,
                url: "#local/" + furl,
                path: path,
                type: 'stylus',
                name: name
              }, {
                wait: true
              });
            });
          }
          return path;
        };
      })(this)));
    };

    Console.prototype.apiGetStylusOutline = function(params, cb) {
      var file, publish;
      file = this.files.find(function(f) {
        return params.url === f.get("url");
      });
      if (!file) {
        return;
      }
      publish = !!params.publish;
      return stylus.getStylusOutline({
        filename: file.srcpath,
        data: params.data,
        getcss: publish
      }, (function(_this) {
        return function(outline, css) {
          cb(outline);
          if (css) {
            return _this.publishData(file, css);
          }
        };
      })(this));
    };

    return Console;

  })();

  Console.consoles = {};

  Console.getConsole = function(projectId) {
    var project, _base;
    if (!(project = Projects.get(projectId))) {
      return null;
    }
    if ((_base = Console.consoles)[projectId] == null) {
      _base[projectId] = new Console(project);
    }
    project.bind("remove", function() {
      var _ref3;
      log.info({
        project: projectId
      }, 'Remove console');
      if ((_ref3 = Console.consoles[projectId]) != null) {
        _ref3.destroy();
      }
      return delete Console.consoles[projectId];
    });
    project.bind("change:files", function() {
      var _ref3;
      log.info({
        project: projectId
      }, 'Console conf changed');
      if ((_ref3 = Console.consoles[projectId]) != null) {
        _ref3.destroy();
      }
      delete Console.consoles[projectId];
      return Console.getConsole(projectId);
    });
    return Console.consoles[projectId];
  };

  module.exports = Console;

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  var fs, log, mkdirp, os, path, request, _;

  path = require('path');

  fs = require('fs');

  mkdirp = require('mkdirp');

  os = require('os');

  request = require('request');

  _ = require('underscore')._;

  log = require('./log');

  exports.getFileLocation = function(project, fileurl, cb) {
    var cssfile, files, fpath, newfiles, srcfile, stylusout, type, url, _i, _len, _ref;
    files = project.get('files');
    if (files) {
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        _ref = files[_i], url = _ref.url, fpath = _ref.path, type = _ref.type, newfiles = _ref.newfiles, stylusout = _ref.stylusout;
        if (0 === fileurl.indexOf(url)) {
          srcfile = cssfile = (fpath + '/' + fileurl.substr(url.length)).replace(/\/+/g, '/');
          if (type === 'stylus') {
            srcfile = srcfile.replace(/\.css$/i, '.styl');
            cssfile = (stylusout + '/' + fileurl.substr(url.length)).replace(/\/+/g, '/');
            newfiles = false;
          }
          return fs.exists(srcfile, function(found) {
            if (found) {
              return cb(null, srcfile, cssfile);
            } else if (newfiles && fileurl.match(/^http/)) {
              log.info({
                project: project.id,
                file: srcfile
              }, 'File was not found. Trying to create new.');
              return request(fileurl, function(error, response, body) {
                var srcdir, writefile;
                if (error || response.statusCode !== 200) {
                  log.warn({
                    file: srcfile,
                    url: fileurl,
                    err: error,
                    statusCode: response != null ? response.statusCode : void 0
                  }, 'Failed to get contents for the file.');
                  body = "";
                } else {
                  log.info({
                    file: srcfile,
                    url: fileurl,
                    statusCode: response.statusCode,
                    length: body.length
                  }, 'Received contents for file.');
                }
                srcdir = path.dirname(srcfile);
                writefile = function() {
                  return fs.writeFile(srcfile, body, 'utf8', function(err) {
                    if (err) {
                      log.error({
                        file: srcfile,
                        err: err
                      }, 'Failed to write new file');
                      return cb(true);
                    } else {
                      log.info({
                        file: srcfile
                      }, 'Created new file');
                      return cb(null, srcfile, cssfile);
                    }
                  });
                };
                return fs.exists(srcdir, function(found) {
                  if (found) {
                    return writefile();
                  } else {
                    log.info({
                      path: dir
                    }, 'Creating directory');
                    return mkdirp(dir, 0x1ed, function() {
                      return writefile();
                    });
                  }
                });
              });
            } else {
              log.warn({
                file: srcfile
              }, 'File was not found. Ignoring.');
              return cb(true);
            }
          });
        }
      }
    }
    log.debug({
      project: project.id,
      url: fileurl
    }, 'File didn\'t match project configuration');
    return cb(true);
  };


  /*
  exports.getStylusAssumption = (project, fileurl) ->
    files = project.get "files"
    if files 
      for {url, daemon} in files
        return !!daemon if (fileurl.indexOf url) == 0
    false
  
  exports.setStylusAssumption = (project, fileurl, value) ->
    files = project.get "files"
    if files 
      for {url},i in files
        files[i].daemon = !!value if (fileurl.indexOf url) == 0
    project.save files:files
   */

  exports.getLocalIPs = (function() {
    var cached;
    cached = null;
    return function(callback, bypassCache) {
      var command, exec, filterRE, interfaces, intrface, ips, name, _i, _len, _ref;
      if (cached && !bypassCache) {
        return callback(cached);
      }
      ips = [];
      if (process.platform.match(/^win/i)) {
        exec = require('child_process').exec;
        command = 'ipconfig';
        filterRE = /\IPv4 Address(.+?)([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)$/gim;
        return exec(command, function(error, stdout, sterr) {
          var match, matches;
          if (!error) {
            matches = stdout.match(filterRE);
            if (matches) {
              ips = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = matches.length; _i < _len; _i++) {
                  match = matches[_i];
                  _results.push(match.match(/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/)[0]);
                }
                return _results;
              })();
            }
          }
          ips.unshift('127.0.0.1');
          return callback(cached = ips);
        });
      } else {
        _ref = os.networkInterfaces();
        for (name in _ref) {
          interfaces = _ref[name];
          for (_i = 0, _len = interfaces.length; _i < _len; _i++) {
            intrface = interfaces[_i];
            if (intrface.family === 'IPv4') {
              ips.push(intrface.address);
            }
          }
        }
        return callback(cached = ips);
      }
    };
  })();

  exports.isAllowedIP = function(allowed, ip) {
    var check, regexp, _i, _len;
    for (_i = 0, _len = allowed.length; _i < _len; _i++) {
      check = allowed[_i];
      check = check.trim();
      if (!check.length) {
        continue;
      }
      regexp = new RegExp("^" + (check.replace(/\./g, "\\.")).replace(/\*/, ".+"));
      if (ip.match(regexp)) {
        return true;
      }
    }
    return false;
  };

  exports.getDriveNames = function(cb) {
    var command, exec;
    if (!process.platform.match(/^win/i)) {
      cb(null);
    }
    exec = require('child_process').exec;
    command = 'wmic logicaldisk get name';
    return exec(command, function(error, stdout, sterr) {
      var match, matches;
      if (error) {
        log.warn({
          err: error,
          output: stdout
        }, 'Failed to get drive names using wmic');
        return callback(error);
      }
      matches = stdout.match(/[a-z]\:/ig);
      if (matches) {
        return cb(matches);
      }
      match = __dirname.match(/^[a-z]\:/i)[0];
      return cb([match] || null);
    });
  };

  exports.pathIsAllowed = function(fpath) {
    if (global.rootDir === '/') {
      return true;
    }
    return 0 === path.normalize(fpath).replace(/\\/g, "/").toLowerCase().indexOf(global.rootDir.toLowerCase());
  };

  exports.getHomeDir = function() {
    return process.env.HOME || process.env.HOMEPATH.replace(/\\/g, '/') || '.';
  };

}).call(this);

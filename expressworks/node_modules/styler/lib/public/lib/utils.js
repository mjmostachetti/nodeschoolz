// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(function(require, exports, module) {
    exports.node = function() {
      var arg, args, attributes, child, children, element, name, value, _i, _j, _len, _len1;
      args = Array.prototype.slice.call(arguments);
      element = document.createElement(args.shift());
      attributes = {};
      children = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        if (!arg) {
          continue;
        }
        if (typeof arg === 'string') {
          children.push(document.createTextNode(arg));
        } else if (arg.nodeType === Node.ELEMENT_NODE) {
          children.push(arg);
        } else if (typeof arg === 'object') {
          _.extend(attributes, arg);
        }
      }
      for (name in attributes) {
        value = attributes[name];
        if (name === 'style' && typeof value === 'object') {
          $(element).css(value);
        } else {
          element.setAttribute(name, value);
        }
      }
      for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
        child = children[_j];
        element.appendChild(child);
      }
      return element;
    };
    exports.style = function(element, styles) {
      var property, value, _results;
      _results = [];
      for (property in styles) {
        value = styles[property];
        _results.push(element.style[property] = value);
      }
      return _results;
    };
    exports.getStyle = function(element, property) {
      var prefix, st, value, _i, _len, _ref;
      st = window.getComputedStyle(element);
      _ref = ['', 'Webkit', 'Moz'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prefix = _ref[_i];
        value = st[prefix + property];
        if (value) {
          return value;
        }
      }
    };
    exports.swapNodes = function(item1, item2) {
      var itemtmp, parent;
      itemtmp = item1.cloneNode(1);
      parent = item1.parentNode;
      item2 = parent.replaceChild(itemtmp, item2);
      parent.replaceChild(item2, item1);
      return parent.replaceChild(item1, itemtmp);
    };
    exports.parallel = function(list, iterator, callback) {
      var item, num, _i, _len, _results;
      num = list.length;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        item = list[_i];
        _results.push(iterator(item, (function() {
          if (!--num) {
            return callback();
          }
        })));
      }
      return _results;
    };
    exports.series = function(list, iterator, callback) {
      if (!list.length) {
        callback();
      }
      return iterator(list[0], function() {
        return exports.series(list.slice(1), iterator, callback);
      });
    };
    exports.basename = function(path) {
      return _.last(path.split('/'));
    };
    exports.combineURLRoots = function(urls) {
      var i, origins, url, _results;
      origins = _.groupBy(urls, function(url) {
        var _ref;
        return (_ref = url.match('^.*?//.*?/')) != null ? _ref[0] : void 0;
      });
      _results = [];
      for (i in origins) {
        urls = origins[i];
        url = _.reduce(urls, function(a, b) {
          return exports.commonPartOfStrings(a, b);
        });
        url = url.match('.*/')[0];
        _results.push(url);
      }
      return _results;
    };
    exports.combineUrl = function(baseUrl, url) {
      var domain, i, last, parts, path, up;
      if (!url.match('^[a-z]{4,5}:\/\/')) {
        if (url[0] === '/') {
          url = baseUrl.match(/^.+[:]\/+[^\/]+/)[0] + url;
        } else {
          parts = baseUrl.split('/');
          url = parts.slice(0, -1).join('/') + '/' + url;
        }
      }
      parts = url.split('/');
      domain = parts.slice(0, 3);
      path = parts.slice(3);
      i = path.length - 1;
      up = 0;
      while (i >= 0) {
        last = path[i];
        if (last === '.') {
          path.splice(i, 1);
        } else if (last === "..") {
          path.splice(i, 1);
          up++;
        } else if (up) {
          path.splice(i, 1);
          up--;
        }
        i--;
      }
      if (up) {
        return null;
      }
      return (domain.concat(path)).join('/');
    };
    exports.commonPartOfStrings = function(s1, s2) {
      var i, str, _i, _ref;
      str = "";
      for (i = _i = 0, _ref = Math.min(s1.length, s2.length); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (s1[i] === s2[i]) {
          str += s1[i];
        } else {
          return str;
        }
      }
    };
    exports.splitToTokens = function(str, sep) {
      var i, parens, parts, quote, st, _ref;
      parens = 0;
      quote = null;
      parts = [];
      st = i = 0;
      while (i < str.length) {
        if (str[i] === sep && !quote && !parens) {
          if (i > st) {
            parts.push([st, str.substr(st, i - st)]);
          }
          st = ++i;
          continue;
        }
        if (!quote) {
          if (_ref = str[i], __indexOf.call('"\'', _ref) >= 0) {
            quote = str[i];
          }
          if (str[i] === '(') {
            parens++;
          }
          if (str[i] === ')' && parens > 0) {
            parens--;
          }
        } else if (quote && str[i] === quote) {
          quote = null;
        }
        i++;
      }
      if (i > st) {
        parts.push([st, str.substr(st, i - st)]);
      }
      return parts;
    };
    exports.getPart = function(txt, sep, offset) {
      var match, out, raw_parts, _ref;
      out = {
        txt: '',
        offset: 0
      };
      raw_parts = exports.splitToTokens(txt, sep);
      out.parts = _.map(raw_parts, function(_arg, i) {
        var part, start;
        start = _arg[0], part = _arg[1];
        if ((start <= offset && offset <= start + part.length)) {
          _.extend(out, {
            txt: part,
            offset: offset - start,
            i: i
          });
        }
        return part;
      });
      if (match = (_ref = out.txt) != null ? _ref.match(/^\s+/) : void 0) {
        out.txt = out.txt.substr(match[0].length);
        out.offset -= match[0].length;
      }
      return out;
    };
    exports.clearEndSpaces = function(value, offset) {
      var hasPadding, o;
      hasPadding = true;
      if (value.length > offset) {
        o = offset;
        while (value.length > o) {
          if (value[o] !== ' ') {
            hasPadding = false;
            break;
          }
          o++;
        }
      } else {
        hasPadding = false;
      }
      if (hasPadding) {
        return value.substr(0, offset);
      } else {
        return value;
      }
    };
    exports.highlightSelector = function(selector) {
      var el, found, incomplete, match, out, parts, regex, type, _i, _len, _ref;
      parts = [
        {
          regex: /^#[a-zA-Z][a-zA-Z0-9_-]*/,
          type: 'sel-id'
        }, {
          regex: /^\.[a-zA-Z][a-zA-Z0-9_-]*/,
          type: 'sel-class'
        }, {
          regex: /^:+[a-zA-Z][a-zA-Z0-9-]*/,
          type: 'sel-pseudo'
        }, {
          regex: /^\(.+?\)/,
          type: 'sel-parens'
        }, {
          regex: /^\[.+?\]/,
          type: 'sel-parens'
        }, {
          regex: /^\+>/,
          type: 'sel-symbol'
        }, {
          regex: /^,/,
          type: 'sel-symbol'
        }, {
          regex: /^[a-zA-Z]+[0-9]?/,
          type: 'sel-tag'
        }
      ];
      out = [];
      incomplete = "";
      while (selector.length) {
        found = false;
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          _ref = parts[_i], regex = _ref.regex, type = _ref.type;
          if (match = selector.match(regex)) {
            if (incomplete.length) {
              out.push({
                type: "sel-unknown",
                txt: incomplete
              });
              incomplete = "";
            }
            out.push({
              type: type,
              txt: match[0]
            });
            selector = selector.substr(match[0].length);
            found = true;
            break;
          }
        }
        if (found) {
          continue;
        }
        incomplete += selector[0];
        selector = selector.substr(1);
      }
      if (incomplete.length) {
        out.push({
          type: 'sel-unknown',
          txt: incomplete
        });
      }
      el = exports.node('span', {
        "class": 'higlighted-selector'
      });
      _.each(out, function(part) {
        var _ref1;
        if ((_ref1 = part.type) === 'sel-class' || _ref1 === 'sel-id') {
          part.txt = part.txt.substr(1);
        }
        return el.appendChild(exports.node('span', {
          "class": part.type
        }, part.txt));
      });
      return el;
    };
    exports.makeToggleFocusable = function(el) {
      $(el).bind('focus', function() {
        return el._focused = 1;
      });
      $(el).bind('blur', function() {
        return el._focused = 0;
      });
      return $(el).bind('click', function() {
        el._focused++;
        if (el._focused > 2) {
          $(el).blur();
          return el._focused = 0;
        }
      });
    };
    exports.formatFileSize = function(size) {
      var i, sizetext;
      sizetext = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
      if (!size) {
        return '0B';
      }
      return (size / Math.pow(1024, (i = Math.floor(Math.log(size) / Math.log(1024))))).toFixed(i === 0 ? 0 : 1) + sizetext[i];
    };
    exports.rgbToHex = function(rgbStr) {
      var blue, green, hex, match, red, rgb;
      match = rgbStr.match(/^rgb\((\d+), (\d+), (\d+)\)$/);
      if (!match) {
        return rgbStr;
      }
      red = parseInt(match[1]);
      green = parseInt(match[2]);
      blue = parseInt(match[3]);
      rgb = blue | green << 8 | red << 16;
      hex = rgb.toString(16);
      while (!(hex.length >= 6)) {
        hex = '0' + hex;
      }
      if (hex[0] === hex[1] && hex[2] === hex[3] && hex[4] === hex[5]) {
        hex = hex[0] + hex[2] + hex[4];
      }
      return '#' + hex.toUpperCase();
    };
    exports.hexToRgb = function(hex) {
      hex = (hex + '').replace(/[(^rgb\()]*?[^a-fA-F0-9,]*/g, '').split(',');
      if (hex.length === 3) {
        return [+hex[0], +hex[1], +hex[2]];
      }
      hex += '';
      if (hex.length === 3) {
        hex = hex.split('');
        return [parseInt(hex[0] + hex[0], 16), parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16)];
      }
      while (hex.length < 6) {
        hex = '0' + hex;
      }
      return [parseInt(hex.substr(0, 2), 16), parseInt(hex.substr(2, 2), 16), parseInt(hex.substr(4, 2), 16)];
    };
    return exports;
  });

}).call(this);

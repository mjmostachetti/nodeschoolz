// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(function(require, exports, module) {
    var StylusManager;
    StylusManager = (function() {
      function StylusManager(tab) {
        this.tab = tab;
        _.bindAll(this, "loadOutline", "onStylusOutline");
        this.complete = false;
        this.haschanged = true;
        this.tab.session.doc.on("change", (function(_this) {
          return function() {
            _this.haschanged = true;
            return setTimeout(_this.loadOutline, 300);
          };
        })(this));
        _.defer(this.loadOutline);
      }

      StylusManager.prototype.ruleForLine = function(lineno) {
        if (!this.outlinelines) {
          return -1;
        }
        while (!this.outlinelines[lineno] && lineno >= 0) {
          lineno--;
        }
        return lineno;
      };

      StylusManager.prototype.ruleForSelectorText = function(selectorText, index) {
        var child, i, _i, _ref;
        i = 0;
        _ref = this.outlinelines;
        for (_i in _ref) {
          child = _ref[_i];
          if (__indexOf.call(child.name, selectorText) >= 0) {
            if (i === index) {
              return child.line;
            } else {
              i++;
            }
          }
        }
        return -1;
      };

      StylusManager.prototype.rangeForRule = function(line) {
        var doc, firstindent, indent, lastindent, length, row, start;
        start = line;
        doc = this.tab.session.doc;
        length = doc.getLength();
        firstindent = lastindent = doc.getLine(line).match(/^\s*/)[0].length;
        while (true) {
          row = doc.getLine(line);
          line++;
          if (row === "" || this.outlinelines[line]) {
            line--;
            break;
          }
          indent = row.match(/^\s*/)[0].length;
          if (indent === row.length) {
            line--;
            break;
          }
          if (indent < lastindent || indent > lastindent && lastindent > firstindent) {
            break;
          }
        }
        return {
          start: start,
          end: line
        };
      };

      StylusManager.prototype.previousRule = function(rule) {
        while (rule >= 0 && !this.outlinelines[rule--]) {
          true;
        }
        return rule + 1;
      };

      StylusManager.prototype.nextRule = function(rule) {
        while (rule <= this.tab.session.doc.getLength() && !this.outlinelines[++rule]) {
          true;
        }
        return rule;
      };

      StylusManager.prototype.selectorTextForRule = function(ruleid) {
        var _ref;
        return (_ref = this.outlinelines[ruleid]) != null ? _ref.name.join(",") : void 0;
      };

      StylusManager.prototype.completionAtPosition = function(_arg) {
        var c, column, doc, firstword, forceSelector, ident, ident2, item, length, line, line2, m, parent, parts, prefixpart, pseudomatch, row, row2, selector, selectors, value, _i, _len, _ref, _ref1;
        row = _arg.row, column = _arg.column;
        doc = this.tab.session.doc;
        line = doc.getLine(row);
        firstword = (_ref = line.match(/\s*(.*?)(:|\s|$)/)) != null ? _ref[1] : void 0;
        forceSelector = row <= (this.firstline != null) || !line.match(/^\s+/);
        if (firstword) {
          if (forceSelector || (firstword.match(/[\.#&>|]/)) || firstword.match(/^(div|span|a|p|br|table|tbody|tr|td|th|li|ul|ol)\b/i)) {
            line = doc.getLine(row);
            if (line[0] === '@') {
              parts = line.split(' ');
              if (column <= parts[0].length) {
                return {
                  type: 'atrule',
                  rule: parts[0],
                  offset: column
                };
              } else {
                return {
                  type: 'atrulevalue',
                  rule: parts[0],
                  value: line.substr(parts[0].length + 1),
                  offset: column - parts[0].length - 1
                };
              }
            }
            selectors = line.split(",");
            ident = (line.match(/^\s*/))[0].length;
            if (ident > column) {
              return;
            }
            prefixpart = line.substr(0, column);
            pseudomatch = prefixpart.match(/:([a-z-]*)$/i);
            if (pseudomatch && (column > line.length - 1 || ((_ref1 = line[column + 1]) != null ? _ref1.match(/^\s$/) : void 0))) {
              return {
                type: "pseudo",
                pseudo: pseudomatch[1],
                offset: pseudomatch[1].length
              };
            }
            c = 0;
            for (_i = 0, _len = selectors.length; _i < _len; _i++) {
              selector = selectors[_i];
              c += selector.length + 1;
              if (!(c >= column)) {
                continue;
              }
            }
            column -= c - selector.length - 1;
            parent = [""];
            row2 = row;
            if (ident !== 0) {
              while (row2) {
                row2--;
                item = this.outlinelines[row2 + 1];
                if (item) {
                  line2 = doc.getLine(row2);
                  ident2 = (line2.match(/^\s*/))[0].length;
                  if (ident2 < ident) {
                    parent = item.name;
                    break;
                  }
                }
              }
            }
            return {
              type: "selector",
              selector: selector,
              parent: parent,
              offset: column
            };
          } else {
            m = line.match(/^(\s*)([^\s:]+)\s*:?\s*/);
            length = m[0].length;
            if (column < length || (length && column === length && m[0][length - 1] !== " ")) {
              if (column - m[1].length === m[2].length) {
                return {
                  type: "property",
                  offset: m[2].length,
                  property: m[2]
                };
              }
            } else {
              value = line.substr(m[0].length);
              return {
                type: "value",
                value: value,
                property: m[2],
                offset: column - length
              };
            }
          }
        }
        return null;
      };

      StylusManager.prototype.loadOutline = function() {
        if (this.loading) {
          return;
        }
        if (this.haschanged) {
          this.haschanged = false;
          this.loading = true;
          return app.console.callAPI("GetStylusOutline", {
            url: this.tab.get("url"),
            publish: app.console.isLiveMode(),
            data: this.tab.session.getValue()
          }, this.onStylusOutline);
        }
      };

      StylusManager.prototype.onStylusOutline = function(outline) {
        var iserr;
        iserr = !!outline.err;
        if (iserr) {
          this.tab.set({
            error: outline
          });
        } else {
          this.outline = outline;
          if (this.tab.get("error")) {
            this.tab.set({
              error: null
            });
          }
          this.outlinelines = {};
          this.firstline = null;
          this.parseOutline(this.outline);
        }
        if (!this.complete) {
          this.complete = true;
          this.trigger("loaded");
        }
        this.trigger("update");
        this.loading = false;
        if (this.haschanged) {
          return setTimeout(this.loadOutline, 300);
        }
      };

      StylusManager.prototype.parseOutline = function(outline) {
        var child, n, n1, n2, name, names, parentnames, _i, _j, _k, _len, _len1, _len2, _ref, _results;
        _ref = outline.child;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          names = child.name;
          if (child.ident) {
            continue;
          }
          parentnames = outline.name;
          if (!parentnames.length) {
            parentnames = [""];
          }
          n = [];
          for (_j = 0, _len1 = names.length; _j < _len1; _j++) {
            n1 = names[_j];
            name = n1.replace(/\s+/g, " ").trim().toLowerCase();
            for (_k = 0, _len2 = parentnames.length; _k < _len2; _k++) {
              n2 = parentnames[_k];
              if ((name.indexOf("&")) !== -1) {
                n.push(name.replace(/&/g, n2));
              } else {
                n.push((n2 + " " + name).trim());
              }
            }
          }
          child.name = n;
          if (this.firstline == null) {
            this.firstline = child.line;
          }
          this.outlinelines[child.line] = child;
          child.parent = outline;
          if (child.child) {
            _results.push(this.parseOutline(child));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      return StylusManager;

    })();
    _.extend(StylusManager.prototype, Backbone.Events);
    return module.exports = StylusManager;
  });

}).call(this);

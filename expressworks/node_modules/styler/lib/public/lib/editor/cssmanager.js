// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(function(require, exports, module) {
    var CSSManager, getPart;
    getPart = require("lib/utils").getPart;
    CSSManager = (function() {
      function CSSManager(tab) {
        this.tab = tab;
        this.complete = false;
        this.tab.session.getMode()._outlineManager = this;
        _.bindAll(this, "publish", "onPublishComplete");
        this.haschanged = true;
        this.tab.session.doc.on("change", (function(_this) {
          return function() {
            _this.haschanged = true;
            return setTimeout(_this.publish, 1);
          };
        })(this));
      }

      CSSManager.prototype.publish = function() {
        if (this.loading) {
          return;
        }
        if (this.haschanged) {
          this.haschanged = false;
          if (app.console.isLiveMode()) {
            this.loading = true;
            return app.console.callAPI("PublishChanges", {
              url: this.tab.get("url"),
              data: this.tab.session.getValue()
            }, this.onPublishComplete);
          }
        }
      };

      CSSManager.prototype.onPublishComplete = function() {
        this.loading = false;
        if (this.haschanged) {
          return setTimeout(this.loadOutline, 300);
        }
      };

      CSSManager.prototype.ruleForLine = function(lineno) {
        while (lineno > 0 && !this.outlinelines[lineno]) {
          lineno--;
        }
        if (lineno === 0 && !this.outlinelines[lineno]) {
          lineno = -1;
        }
        return lineno;
      };

      CSSManager.prototype.ruleForSelectorText = function(selectorText, index) {
        var child, i, _i, _ref;
        i = 0;
        selectorText = selectorText.toLowerCase();
        _ref = this.outlinelines;
        for (_i in _ref) {
          child = _ref[_i];
          if (__indexOf.call(child.selector, selectorText) >= 0) {
            if (i === index) {
              return child.line;
            } else {
              i++;
            }
          }
        }
        return -1;
      };

      CSSManager.prototype.rangeForRule = function(line) {
        var doc, leftcurly, row, start;
        start = line;
        doc = this.tab.session.doc;
        leftcurly = 0;
        while (true) {
          if (line > doc.getLength()) {
            break;
          }
          row = doc.getLine(line - 1).replace(/\/\*.*\*\//g, "");
          if ((row.indexOf("{")) !== -1) {
            leftcurly++;
          }
          if (leftcurly > 1) {
            line--;
            break;
          }
          if ((row.indexOf("}")) !== -1) {
            break;
          }
          line++;
        }
        return {
          start: start,
          end: line
        };
      };

      CSSManager.prototype.previousRule = function(rule) {
        while (rule >= 0 && !this.outlinelines[--rule]) {
          true;
        }
        return rule;
      };

      CSSManager.prototype.nextRule = function(rule) {
        while (rule <= this.tab.session.doc.getLength() && !this.outlinelines[++rule]) {
          true;
        }
        return rule;
      };

      CSSManager.prototype.selectorTextForRule = function(ruleid) {
        var _ref;
        return (_ref = this.outlinelines[ruleid]) != null ? _ref.selector.join(",") : void 0;
      };

      CSSManager.prototype.completionAtPosition = function(_arg) {
        var cc, column, doc, hasbrace, lbraceindex, line, part, parts, prefixpart, property, pseudomatch, rbraceindex, row, rr, selector, stmt, type, _ref, _ref1, _ref2;
        row = _arg.row, column = _arg.column;
        doc = this.tab.session.doc;
        type = 0;
        rr = row;
        cc = column;
        while (!type && rr >= 0) {
          line = doc.getLine(rr);
          rbraceindex = line.indexOf("}");
          if (rbraceindex !== -1 && rbraceindex < cc) {
            type = 1;
          }
          lbraceindex = line.indexOf("{");
          hasbrace = lbraceindex !== -1;
          if (hasbrace) {
            if (lbraceindex < cc) {
              type = 2;
            } else {
              type = 1;
            }
          } else if (this.outlinelines[rr + 1]) {
            type = 1;
          }
          rr--;
          cc = 1000;
        }
        if (rr < 0) {
          type = 1;
        }
        line = doc.getLine(row);
        if (type === 1) {
          line = line.replace(/\{.*$/, "");
          if (line[0] === '@') {
            parts = line.split(' ');
            if (column <= parts[0].length) {
              return {
                type: 'atrule',
                rule: parts[0],
                offset: column
              };
            } else {
              return {
                type: 'atrulevalue',
                rule: parts[0],
                value: line.substr(parts[0].length + 1),
                offset: column - parts[0].length - 1
              };
            }
          }
          selector = getPart(line, ",", column);
          if (!(selector != null ? (_ref = selector.txt) != null ? _ref.length : void 0 : void 0)) {
            return;
          }
          prefixpart = line.substr(0, column);
          pseudomatch = prefixpart.match(/:([a-z-]*)$/i);
          if (pseudomatch && (column > line.length - 1 || ((_ref1 = line[column + 1]) != null ? _ref1.match(/^\s$/) : void 0))) {
            return {
              type: "pseudo",
              pseudo: pseudomatch[1],
              offset: pseudomatch[1].length
            };
          }
          return {
            type: "selector",
            selector: selector.txt,
            parent: [""],
            offset: selector.offset
          };
        } else {
          stmt = getPart(line, "{", column);
          stmt = getPart(stmt.txt, "}", stmt.offset);
          stmt = getPart(stmt.txt, ";", stmt.offset);
          if (!(stmt != null ? (_ref2 = stmt.txt) != null ? _ref2.length : void 0 : void 0)) {
            return;
          }
          part = getPart(stmt.txt, ":", stmt.offset);
          if ((part != null ? part.txt : void 0) == null) {
            return;
          }
          if (part.i === 0) {
            if (part.txt.length > part.offset) {
              return null;
            }
            return {
              type: "property",
              offset: part.offset,
              property: part.txt
            };
          } else if (part.i === 1) {
            property = stmt.txt.split(":")[0].trim();
            return {
              type: "value",
              value: part.txt,
              property: property,
              offset: part.offset
            };
          }
        }
        return null;
      };

      CSSManager.prototype.setOutline = function(outline) {
        var item, _i, _len;
        this.outlinelines = {};
        for (_i = 0, _len = outline.length; _i < _len; _i++) {
          item = outline[_i];
          item.selector = item.selector.split(",");
          this.outlinelines[item.line] = item;
        }
        if (!this.complete) {
          this.complete = true;
          this.trigger("loaded");
        }
        return this.trigger("update");
      };

      return CSSManager;

    })();
    _.extend(CSSManager.prototype, Backbone.Events);
    return module.exports = CSSManager;
  });

}).call(this);

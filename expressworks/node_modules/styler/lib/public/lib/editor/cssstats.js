// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(function(require, exports, module) {
    var addColor, hex2rgba;
    hex2rgba = function(hex) {
      hex = hex.substr(1);
      if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }
      return [parseInt(hex.substr(0, 2), 16), parseInt(hex.substr(2, 2), 16), parseInt(hex.substr(4, 2), 16), 1];
    };
    addColor = function(out, color) {
      var key, rgb;
      rgb = color.rgb;
      key = rgb.join("_");
      if (out[key]) {
        return out[key].count++;
      } else {
        return out[key] = {
          count: 1,
          rgb: color.rgb,
          hex: color.hex
        };
      }
    };
    return exports.getStats = function(data) {
      var color, colors, component, components, count, fontfamily, fontfamilys, fontregexp, fontregexp2, fonts, hex, hexcolors, i, ispercentage, key, name, out, part, parts, rgbcolor, rgbcolors, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;
      out = {
        colors: {},
        fonts: {}
      };
      hexcolors = data.match(/(#[0-9a-f]{3}|#[0-9a-f]{6})\b/ig);
      if (hexcolors) {
        for (_i = 0, _len = hexcolors.length; _i < _len; _i++) {
          hex = hexcolors[_i];
          addColor(out.colors, {
            hex: hex.toLowerCase(),
            rgb: hex2rgba(hex)
          });
        }
      }
      rgbcolors = data.match(/rgba?\s*\([0-9\.,\s%]{5,}\)/ig);
      if (rgbcolors) {
        for (_j = 0, _len1 = rgbcolors.length; _j < _len1; _j++) {
          rgbcolor = rgbcolors[_j];
          components = rgbcolor.match(/[0-9\.\s]+%?/);
          if (components.length === 3 || components.length === 4) {
            color = [];
            for (i = _k = 0, _len2 = components.length; _k < _len2; i = ++_k) {
              component = components[i];
              value = parseFloat(component.match(/[0-9\.]+/));
              ispercentage = -1 !== component.indexOf("%");
              if (ispercentage) {
                value *= 2.55;
              }
              color.push(i < 3 ? Math.round(value) : value);
            }
            if (color.length < 4) {
              color.push(1);
            }
            addColor(out.colors, {
              rgb: color
            });
          }
        }
      }
      colors = [];
      _ref = out.colors;
      for (key in _ref) {
        color = _ref[key];
        colors.push(color);
      }
      out.colors = colors;
      fontregexp = /font-family\s*:\s*.*?(;|\n)/ig;
      fontregexp2 = /font-family\s*:\s*(.*?)(;|\n)/i;
      fontfamilys = data.match(fontregexp);
      if (fontfamilys) {
        for (_l = 0, _len3 = fontfamilys.length; _l < _len3; _l++) {
          fontfamily = fontfamilys[_l];
          value = (fontfamily.match(fontregexp2))[1];
          if (!value) {
            continue;
          }
          parts = value.split(",");
          for (i = _m = 0, _len4 = parts.length; _m < _len4; i = ++_m) {
            part = parts[i];
            part = part.trim();
            if ((_ref1 = part[0], __indexOf.call("'\"", _ref1) >= 0) && (_ref2 = part.slice(-1)[0], __indexOf.call("'\"", _ref2) >= 0)) {
              part = part.substr(1, part.length - 2);
            }
            part = part.replace(/['"]/g, "");
            if (part === "monospace" || part === "serif" || part === "sans-serif" || part === "cursive" || part === "fantasy") {
              continue;
            }
            if (out.fonts[part]) {
              out.fonts[part]++;
            } else {
              out.fonts[part] = 1;
            }
          }
        }
      }
      fonts = [];
      _ref3 = out.fonts;
      for (name in _ref3) {
        count = _ref3[name];
        fonts.push({
          name: name,
          count: count
        });
      }
      out.fonts = fonts;
      return out;
    };
  });

}).call(this);

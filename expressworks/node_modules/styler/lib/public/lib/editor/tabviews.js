// Generated by CoffeeScript 1.7.1
(function() {
  define(function(require, exports, module) {
    var TABS_SPACING, TabListView, TabView, node;
    node = require('lib/utils').node;
    TABS_SPACING = 5;
    TabView = Backbone.View.extend({
      className: 'tab',
      events: {
        'click .close-btn': 'onCloseClick',
        'mousedown': 'onMouseDown'
      },
      initialize: function() {
        _.bindAll(this, 'onMouseMove', 'onMouseUp');
        this.$el.append([
          this.name = node('div'), node('div', {
            "class": 'close-btn'
          })
        ]);
        this.model.on('destroy', this.onRemove, this);
        this.model.on('change:selected', this.onSelectedChange, this);
        this.model.on('change:highlight', this.onHighlightChange, this);
        this.model.on('change:error', this.renderError, this);
        this.model.on('change:saved', this.render, this);
        this.model._view = this;
        return _.delay((function(_this) {
          return function() {
            return _this.$el.addClass('is-loaded');
          };
        })(this), 1000);
      },
      onCloseClick: function(e) {
        return this.model.tryClose();
      },
      onRemove: function() {
        var _ref;
        this.$el.remove();
        if ((_ref = this.errorEl) != null ? _ref.parentNode : void 0) {
          return $(this.errorEl).remove();
        }
      },
      setOffset: function(offset) {
        this.model.set({
          offset: offset
        });
        return this.$el.css({
          left: offset
        });
      },
      select: function() {
        if (!this.model.collection) {
          return;
        }
        return this.model.select();
      },
      renderError: function() {
        var error, isSelected, _ref, _ref1;
        error = this.model.get('error');
        isSelected = this.model.get('selected');
        if (error && isSelected) {
          if (this.errorEl == null) {
            this.errorEl = node('div', {
              "class": 'editor-error'
            });
          }
          this.errorEl.innerHTML = "" + error.name + " at line " + error.line + ": " + error.message;
          if (((_ref = this.errorEl.parentNode) != null ? _ref.parentNode : void 0) !== this.el) {
            return this.$el.parent().append(this.errorEl);
          }
        } else if ((_ref1 = this.errorEl) != null ? _ref1.parentNode : void 0) {
          return $(this.errorEl).remove();
        }
      },
      onSelectedChange: function() {
        this.$el.toggleClass('is-selected', this.model.get('selected'));
        return this.renderError();
      },
      onHighlightChange: function() {
        var _ref;
        return this.$el.toggleClass('is-highlight', (_ref = this.model.hlmarkers) != null ? _ref.length : void 0);
      },
      render: function() {
        this.name.innerHTML = this.model.get('name');
        if (!this.model.get('saved')) {
          this.name.innerHTML += '*';
        }
        return this;
      },
      getWidth: function() {
        return this.width = this.el.offsetWidth;
      },
      onMouseDown: function(e) {
        if (e.button === 2 || $(e.target).hasClass('close-btn')) {
          return;
        }
        this.select();
        this.isDragging = true;
        if (this._dragManager) {
          this._dragManager.startDrag(this.model);
        }
        this.startPosition = e.clientX;
        return $(window).on('mousemove', this.onMouseMove).on('mouseup', this.onMouseUp);
      },
      onMouseMove: function(e) {
        if (!this.isDragging) {
          return;
        }
        return this._dragManager.moveDrag(e.clientX - this.startPosition);
      },
      onMouseUp: function(e) {
        if (!this.isDragging) {
          return;
        }
        this.isDragging = false;
        this._dragManager.endDrag();
        return $(window).off('mousemove', this.onMouseMove).off('mouseup', this.onMouseUp);
      }
    });
    TabListView = Backbone.View.extend({
      initialize: function() {
        this.collection.on('add', this.onAddTab, this);
        this.collection.on('reset', this.onAddAllTabs, this);
        return this.collection.on('remove', this.onTabRemoved, this);
      },
      onAddTab: function(tab) {
        var t;
        t = new TabView({
          model: tab
        });
        t._dragManager = this;
        this.$el.append(t.render().el);
        this.positionTabs();
        return this.saveOrder();
      },
      onAddAllTabs: function(tabs) {
        return tabs.each(_.bind(this.addOne, this));
      },
      onTabRemoved: function() {
        return this.positionTabs();
      },
      saveOrder: function() {
        return this.collection.each(function(t) {
          var file, fileoffset, offset;
          offset = t.get('offset');
          file = t.get('file');
          fileoffset = file.get('offset');
          if (fileoffset !== offset) {
            return file.save({
              offset: offset
            });
          }
        });
      },
      positionTabs: function() {
        var offset;
        offset = 0;
        return this.collection.each((function(_this) {
          return function(t) {
            if (t !== _this.draggedTab) {
              t._view.setOffset(offset);
            }
            return offset += t._view.getWidth() + TABS_SPACING;
          };
        })(this));
      },
      startDrag: function(tab) {
        this.draggedTab = tab;
        this.startPosition = tab._view.el.offsetLeft;
        return $(tab._view.el).addClass('is-dragging');
      },
      moveDrag: function(delta) {
        var maxPos, pos;
        pos = this.startPosition + delta;
        if (pos < -1) {
          pos = -1;
        }
        maxPos = this.el.offsetWidth - this.draggedTab._view.getWidth();
        if (pos > maxPos) {
          pos = maxPos;
        }
        this.draggedTab._view.setOffset(pos);
        this.collection.sort({
          silent: true
        });
        return this.positionTabs();
      },
      endDrag: function() {
        $(this.draggedTab._view.el).removeClass('is-dragging');
        this.draggedTab = null;
        this.positionTabs();
        return this.saveOrder();
      }
    });
    return {
      TabView: TabView,
      TabListView: TabListView
    };
  });

}).call(this);

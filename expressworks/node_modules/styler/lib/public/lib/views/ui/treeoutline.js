// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(function(require, exports, module) {
    var INDENT, LINE_HEIGHT, TreeOutline, addKeyboardListener, addMouseWheelListener, highlightSelector, listenKey, node, style, ua, _ref, _ref1;
    require('vendor/link!css/treeoutline.css');
    addMouseWheelListener = require('ace/lib/event').addMouseWheelListener;
    ua = require('ace/lib/useragent');
    _ref = require('lib/utils'), node = _ref.node, highlightSelector = _ref.highlightSelector, style = _ref.style;
    _ref1 = require('lib/keyboard'), addKeyboardListener = _ref1.addKeyboardListener, listenKey = _ref1.listenKey;
    LINE_HEIGHT = 20;
    INDENT = 11;
    TreeOutline = Backbone.View.extend({
      attributes: {
        tabindex: 0
      },
      className: 'elements-outline',
      events: function() {
        return {
          'click .subtree-heading > .clear-subtree-btn': 'clearSubtree'
        };
      },
      initialize: function() {
        _.bindAll(this, 'onItemClick', 'onResize', 'onScroll', 'saveScrollPosition');
        this.edge = 0;
        this.saveScrollPosition = _.throttle(this.saveScrollPosition, 400);
        this.$el.append(node('div', {
          "class": 'subtree-heading'
        }, node('div', {
          "class": 'clear-subtree-btn'
        }), node('div', {
          "class": 'element-name'
        })));
        this.$el.append(node('div', {
          "class": 'scroller-container'
        }, this.scrollerEl = node('div', {
          "class": 'scroller'
        }, this.scrollerContentsEl = node('div', {
          "class": 'items-container'
        }, this.itemsEl = node('div', {
          "class": 'items'
        })))));
        $(this.scrollerEl).on('scroll', _.throttle(this.onScroll, ua.isWebkit ? 30 : 60));
        $(this.itemsEl).on('click', this.onItemClick);
        $(window).on('resize', this.onResize);
        app.console.bind('change:pseudo', (function(_this) {
          return function(pseudo) {
            return _this.setPseudoValue(pseudo.elementId, pseudo);
          };
        })(this));
        addKeyboardListener('outline', this.el);
        this.el.listenKey('select-next-element', {
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(1);
            };
          })(this)
        });
        this.el.listenKey('select-previous-element', {
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(-1);
            };
          })(this)
        });
        this.el.listenKey('select-down-many', {
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(10);
            };
          })(this)
        });
        this.el.listenKey('select-up-many', {
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(-10);
            };
          })(this)
        });
        this.el.listenKey('_select-down-many', {
          mac: 'pagedown',
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(10);
            };
          })(this)
        });
        this.el.listenKey('_select-up-many', {
          mac: 'pageup',
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(-10);
            };
          })(this)
        });
        this.el.listenKey('select-last', {
          mac: 'end',
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(1e6);
            };
          })(this)
        });
        this.el.listenKey('select-first', {
          mac: 'home',
          exec: (function(_this) {
            return function() {
              return _this.moveSelection(-1e6);
            };
          })(this)
        });
        this.el.listenKey('fold-element', {
          exec: (function(_this) {
            return function() {
              return _this.unfoldAt(_this.selectedIndex);
            };
          })(this)
        });
        this.el.listenKey('unfold-element', {
          exec: (function(_this) {
            return function() {
              return _this.foldAt(_this.selectedIndex);
            };
          })(this)
        });
        this.el.listenKey('select-outline-subtree', {
          exec: (function(_this) {
            return function() {
              return _this.selectSubtree(_this.selectedIndex);
            };
          })(this)
        });
        this.el.listenKey('hide-outline-subtree', {
          exec: (function(_this) {
            return function() {
              return _this.selectSubtree();
            };
          })(this)
        });
        this.el.listenKey('focus-element-styleinfo', {
          exec: (function(_this) {
            return function() {
              return _this.trigger('focus:styleinfo');
            };
          })(this)
        });
        listenKey(null, 'scroll-to-view', {
          exec: (function(_this) {
            return function() {
              if (_this.selectedIndex !== -1) {
                return _this.scrollToIndex(_this.selectedIndex);
              }
            };
          })(this)
        });
        this.selectedIndex = -1;
        this.setDirty();
        return this.onResize();
      },
      setDirty: function(from) {
        if (from == null) {
          from = 0;
        }
        if (from === false) {
          this.offsetDirty = false;
          return this.dirtyFrom = void 0;
        } else {
          this.offsetDirty = true;
          if ((this.dirtyFrom == null) || from < this.dirtyFrom) {
            return this.dirtyFrom = from;
          }
        }
      },
      _isEqualNode: function(n1, n2) {
        var i, _i, _ref2, _ref3, _ref4, _ref5;
        if (n1 && (n1 != null ? n1.name : void 0) === (n2 != null ? n2.name : void 0)) {
          if (((_ref2 = n1.c) != null ? _ref2.length : void 0) && ((_ref3 = n1.c) != null ? _ref3.length : void 0) === ((_ref4 = n2.c) != null ? _ref4.length : void 0)) {
            for (i = _i = 0, _ref5 = n1.c.length; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
              if (!this._isEqualNode(n1.c[i], n2.c[i])) {
                break;
              }
            }
            return true;
          }
        }
        return false;
      },
      _parseData: function(data, indent, parent) {
        var c, count, inline, isinline, l, line, line_inline, maxindent, mi, prev, prevnode, _i, _len, _ref2;
        if (indent == null) {
          indent = 0;
        }
        if (parent == null) {
          parent = null;
        }
        c = 0;
        prevnode = null;
        maxindent = indent;
        isinline = true;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          line = data[_i];
          mi = indent;
          c++;
          l = {
            i: this.lines.length,
            offset: this.lines.length,
            indent: indent
          };
          if (typeof line === 'string') {
            l.text = line;
          } else {
            if (line.d) {
              l.text = line.d;
            }
            l.name = line.n;
            l.id = line.id;
            l.c = line.c;
            l.parent = parent;
            line_inline = !!line.n.match(/^(span|b|i|u|a|font|strong|p|img)\b/);
            if (isinline && !line_inline) {
              isinline = false;
            }
          }
          this.lines.push(l);
          if (line.c) {
            _ref2 = this._parseData(line.c, indent + 1, l), count = _ref2.count, mi = _ref2.mi, inline = _ref2.inline;
            if (mi > maxindent) {
              maxindent = mi;
            }
            if (isinline && !inline) {
              isinline = false;
            }
            c += l.count = count;
          }
          if (this._isEqualNode(prev, l)) {
            l.autofold = true;
          } else if (indent > 4 && (mi > indent && mi - indent < 4)) {
            l.autofold = true;
          } else if (line_inline === false && inline && count > 5) {
            l.autofold = true;
          }
          prev = l;
        }
        return {
          count: c,
          mi: maxindent,
          inline: isinline
        };
      },
      _getLineName: function(line) {
        var name;
        name = '';
        while (line && name.length < 25) {
          name = line.name + ' ' + name;
          line = line.parent;
        }
        return name;
      },
      _updateOffsets: function() {
        var first, i, j, len, line, offset;
        this.offsets = [];
        i = 0;
        len = this.lines.length;
        while (i < len) {
          line = this.lines[i];
          first = 0;
          if ((this.subtree == null) || (this.subtree <= i && i <= this.subtree + this.lines[this.subtree].count)) {
            offset = this.offsets.length;
            this.offsets.push(i);
          } else {
            offset = -1;
          }
          line.offset = offset;
          if (line.fold) {
            j = i;
            i = line.count + j + 1;
            while (++j < i) {
              this.lines[j].offset = -2;
            }
          } else {
            i++;
          }
        }
        return this.setDirty(false);
      },
      onResize: function() {
        var height, isPositionedBySelection;
        $(this.scrollerEl).css({
          height: height = this.el.offsetHeight
        });
        if (height !== this.containerHeight) {
          this.containerHeight = height;
          if (this.scrollPosition) {
            isPositionedBySelection = this.scrollPosition.selection;
            this.restoreScrollPosition();
            if (isPositionedBySelection) {
              this.scrollToIndex(this.selectedIndex);
            }
          }
        }
        return this;
      },
      onScroll: function(e) {
        return this.scrollTo(this.scrollerEl.scrollTop);
      },
      moveSelection: function(delta) {
        var offset;
        if (this.selectedIndex == null) {
          return this.selectAt(0);
        }
        offset = this.getOffset(this.selectedIndex);
        offset += delta;
        return this.selectAt(offset, delta < 0);
      },
      selectAt: function(offset, moveTopIfNotFound, openFirstRule) {
        var index, last, line;
        if (moveTopIfNotFound == null) {
          moveTopIfNotFound = true;
        }
        if (openFirstRule == null) {
          openFirstRule = false;
        }
        if (this.offsetDirty) {
          this._updateOffsets();
        }
        if (offset < 0) {
          offset = 0;
        }
        last = this.offsets.length - 1;
        if (offset >= last) {
          offset = last;
        }
        index = this.getIndexAt(offset);
        if (index === -1) {
          return;
        }
        line = this.lines[index];
        if (line.id == null) {
          if (moveTopIfNotFound) {
            if (index === 0) {
              return this.selectAt(offset, false);
            } else {
              return this.selectAt(offset - 1, true);
            }
          } else {
            if (index === last) {
              return this.selectAt(offset, true);
            } else {
              return this.selectAt(offset + 1, false);
            }
          }
        }
        return this.selectIndex(index, true, openFirstRule);
      },
      selectIndex: function(index, scroll, openFirstRule) {
        var l, line, offset;
        if (scroll == null) {
          scroll = true;
        }
        if (openFirstRule == null) {
          openFirstRule = false;
        }
        if (index === -1) {
          return;
        }
        if (this.selectedIndex != null) {
          $(this.lines[this.selectedIndex].el).removeClass('is-selected');
        }
        offset = this.getOffset(index);
        if (offset === -1) {
          this.clearSubtree();
          offset = this.getOffset(index);
        }
        if (offset === -2) {
          l = this.lines[index];
          while (l) {
            if (l.fold) {
              this.unfoldAt(l.i);
            }
            l = l.parent;
          }
          this._updateOffsets();
        }
        this.selectedIndex = index;
        line = this.lines[index];
        $(line.el).addClass('is-selected');
        this.trigger('select', {
          index: index,
          id: line.id,
          openFirst: openFirstRule
        });
        if (scroll) {
          this.scrollToIndex(index);
          return this.storeScrollPosition();
        }
      },
      selectedId: function() {
        var line;
        if (this.selectedIndex !== -1 && (line = this.lines[this.selectedIndex])) {
          return line.id;
        }
        return null;
      },
      selectParent: function(level) {
        var line;
        if (this.selectedIndex !== -1) {
          line = this.lines[this.selectedIndex];
          while (level-- > 0) {
            line = line != null ? line.parent : void 0;
          }
          if (line) {
            return this.selectIndex(line.i);
          }
        }
      },
      select: function(id, scroll) {
        var i;
        if (scroll == null) {
          scroll = true;
        }
        i = this.getIndex(id);
        if (i !== -1) {
          return this.selectIndex(i, scroll);
        }
      },
      onItemClick: function(e) {
        var firstItemY, index, offset;
        firstItemY = $(e.target).closest('.outline-item').get(0).offsetTop + (e.offsetY || e.layerY);
        offset = Math.floor(firstItemY / LINE_HEIGHT) + this.scrollOffset;
        this.selectAt(offset, true, e.detail === 2);
        index = this.getIndexAt(offset);
        if (e.detail === 2 && this.lines[index].c && this.lines[index].fold === 1) {
          return this.unfoldAt(index);
        } else if ($(e.target).hasClass('fold-btn')) {
          if (this.lines[index].fold === 1) {
            return this.unfoldAt(index);
          } else {
            return this.foldAt(index);
          }
        } else if ($(e.target).hasClass('select-subtree-btn')) {
          return this.selectSubtree(index);
        }
      },
      highlight: function(highlightedItems) {
        this.highlightedItems = highlightedItems;
        if (this.complete) {
          return this.onScroll();
        }
      },
      selectSubtree: function(index) {
        var line;
        this.subtree = index;
        if (this.subtree != null) {
          line = this.lines[index];
          $(this.itemsEl).css({
            marginLeft: -line.indent * INDENT,
            left: line.indent * INDENT
          });
          this.$('.subtree-heading .element-name').html(highlightSelector(this._getLineName(line)));
        } else {
          $(this.itemsEl).css({
            marginLeft: 0,
            left: 0
          });
        }
        this.$('.subtree-heading').toggleClass('is-visible', this.subtree != null);
        this.setDirty();
        return this.scrollTo(0);
      },
      clearSubtree: function() {
        return this.selectSubtree();
      },
      getIndex: function(id) {
        var i, line, _i, _len, _ref2;
        _ref2 = this.lines;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          line = _ref2[i];
          if (line.id === id) {
            return i;
          }
        }
        return -1;
      },
      createPseudoInfo: function(line) {
        var el, pseudoClass, _i, _len, _ref2, _results;
        if (!line.pseudoEl) {
          $(line.el).find('.selector').before(line.pseudoEl = node('span', {
            "class": 'pseudos'
          }));
        }
        $(line.pseudoEl).empty();
        if (!line.pseudos) {
          return;
        }
        _ref2 = line.pseudos;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          pseudoClass = _ref2[_i];
          if (!(pseudoClass)) {
            continue;
          }
          $(line.pseudoEl).append(el = node('span', {
            "class": 'pseudo-indicator ' + pseudoClass
          }));
          _results.push($(el).bind('click', _.bind(this.clearPseudo, this, line.id, pseudoClass)));
        }
        return _results;
      },
      clearPseudo: function(id, dataClass, e) {
        app.console.setPseudoValue(id, dataClass, false);
        e.stopPropagation();
        return e.preventDefault();
      },
      setPseudoValue: function(lineno, pseudo) {
        var index, line;
        if (lineno == null) {
          return;
        }
        index = this.getIndex(lineno);
        line = this.lines[index];
        line.pseudos = pseudo.get('pseudos');
        if (line.el) {
          return this.createPseudoInfo(line);
        }
      },
      foldAt: function(lineno, notrigger) {
        var line;
        if (notrigger == null) {
          notrigger = false;
        }
        if (lineno == null) {
          return;
        }
        line = this.lines[lineno];
        if (!(!line.fold && line.count)) {
          return;
        }
        line.fold = 1;
        this.setDirty(lineno);
        $(line.el).addClass('is-folded');
        if (!notrigger) {
          this.restoreScrollPosition();
          return this.trigger('fold', {
            index: lineno,
            id: line.id
          });
        }
      },
      unfoldAt: function(lineno, notrigger) {
        var line;
        if (notrigger == null) {
          notrigger = false;
        }
        if (lineno == null) {
          return;
        }
        line = this.lines[lineno];
        if (!line.fold) {
          return;
        }
        line.fold = 0;
        this.setDirty(lineno);
        $(line.el).removeClass('is-folded');
        if (!notrigger) {
          this.restoreScrollPosition();
          return this.trigger('unfold', {
            index: lineno,
            id: line.id,
            wasauto: !!line.autofold
          });
        }
      },
      getIndexAt: function(offset) {
        if (this.offsetDirty) {
          this._updateOffsets();
        }
        return this.offsets[offset];
      },
      getOffset: function(index) {
        if (this.offsetDirty) {
          this._updateOffsets();
        }
        return this.lines[index].offset;
      },
      scrollToIndex: function(index) {
        var diff, height, offset;
        offset = this.getOffset(index);
        diff = (offset - this.scrollOffset) * LINE_HEIGHT - this.edge;
        if (diff < 0) {
          this.scrollerEl.scrollTop = offset * LINE_HEIGHT;
        }
        height = this.containerHeight - LINE_HEIGHT * (this.subtree ? 2 : 1);
        if (diff > height) {
          return this.scrollerEl.scrollTop = offset * LINE_HEIGHT - height;
        }
      },
      storeScrollPosition: function() {
        var diff, offset;
        this.scrollPosition = null;
        if (this.selectedIndex !== -1 && this.selectedIndex !== null) {
          offset = this.getOffset(this.selectedIndex);
          diff = offset * LINE_HEIGHT - this.scrollOffset * LINE_HEIGHT - this.edge;
          if (diff >= 0 && diff <= this.containerHeight - LINE_HEIGHT) {
            this.scrollPosition = {
              offset: diff,
              selection: true
            };
          }
        }
        if (!this.scrollPosition) {
          this.scrollPosition = {
            offset: this.scrollOffset || this.scrollerEl.scrollTop,
            selection: false
          };
        }
        return this.saveScrollPosition();
      },
      saveScrollPosition: function() {
        var _ref2, _ref3;
        return (_ref2 = app.console) != null ? (_ref3 = _ref2.state) != null ? _ref3.save({
          scrollPos: this.scrollPosition
        }) : void 0 : void 0;
      },
      restoreScrollPosition: function() {
        var offset, scroll, _ref2, _ref3;
        this.complete = 1;
        if (((_ref2 = this.scrollPosition) != null ? _ref2.selection : void 0) && this.selectedIndex !== null) {
          offset = this.getOffset(this.selectedIndex);
          scroll = offset * LINE_HEIGHT - this.scrollPosition.offset;
        } else {
          scroll = ((_ref3 = this.scrollPosition) != null ? _ref3.offset : void 0) || 0;
        }
        this.scrollTo(scroll, true);
        this.scrollerEl.scrollTop = scroll;
        return this.storeScrollPosition();
      },
      scrollTo: function(offset, noStorePosition) {
        var el, end, index, itemOffset, lastElement, line, maxLines, maxOffset, next, oy, row, rows, totalLines, _i, _len;
        if (noStorePosition == null) {
          noStorePosition = false;
        }
        if (!this.lines) {
          return;
        }
        if (this.offsetDirty) {
          this._updateOffsets();
        }
        if (offset < 0) {
          offset = 0;
        }
        maxLines = (Math.ceil(this.containerHeight / LINE_HEIGHT)) + (this.subtree != null ? 0 : 1);
        totalLines = this.offsets.length;
        maxOffset = totalLines - maxLines + 1;
        if (maxOffset < 0) {
          maxOffset = 0;
        }
        oy = Math.floor(offset / LINE_HEIGHT);
        this.edge = offset % LINE_HEIGHT;
        offset = oy > maxOffset ? maxOffset : oy;
        end = offset + maxLines < totalLines ? offset + maxLines : totalLines;
        this.repaintIndex = !this.repaintIndex;
        rows = (function() {
          var _i, _results;
          _results = [];
          for (itemOffset = _i = offset; offset <= end ? _i < end : _i > end; itemOffset = offset <= end ? ++_i : --_i) {
            index = this.getIndexAt(itemOffset);
            line = this.lines[index];
            if (!(line != null ? line.el : void 0)) {
              if (!line.name && line.text) {
                line.text = '| ' + line.text;
              }
              el = $(node('div', {
                "class": 'outline-item',
                style: {
                  paddingLeft: line.indent * INDENT + 'px'
                }
              }));
              if (line.count) {
                el.append(node('span', {
                  "class": 'fold-btn'
                }));
                el.append(node('div', {
                  "class": 'select-subtree-btn'
                }));
              } else {
                el.append(node('span', {
                  "class": 'fold-btn-blank'
                }));
              }
              if (line.name) {
                el.append(node('span', {
                  "class": 'selector'
                }, highlightSelector(line.name)));
              }
              if (line.text) {
                el.append(node('span', {
                  "class": 'text'
                }, line.text));
              }
              if (line.fold) {
                el.addClass('is-folded');
              }
              if (index === this.selectedIndex) {
                el.addClass('is-selected');
              }
              line.el = el;
              if (line.pseudos) {
                this.createPseudoInfo(line);
              }
            }
            line.el.toggleClass('is-highlighted', this.highlightedItems && __indexOf.call(this.highlightedItems, index) >= 0);
            el = line.el.get(0);
            el._lastRepaintIndex = this.repaintIndex;
            _results.push(el);
          }
          return _results;
        }).call(this);
        $(this.itemsEl).hide().css({
          top: offset * LINE_HEIGHT
        });
        if (this._doCleanDOM === true) {
          $(this.itemsEl).empty();
          this._doCleanDOM = false;
        }
        lastElement = null;
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          row = rows[_i];
          if (row.parentNode !== this.itemsEl) {
            if (lastElement) {
              if (lastElement.nextSibling) {
                this.itemsEl.insertBefore(row, lastElement.nextSibling);
              } else {
                this.itemsEl.appendChild(row);
              }
            } else {
              if (this.itemsEl.firstChild) {
                this.itemsEl.insertBefore(row, this.itemsEl.firstChild);
              } else {
                this.itemsEl.appendChild(row);
              }
            }
          }
          lastElement = row;
        }
        el = this.itemsEl.firstChild;
        while (el) {
          next = el.nextSibling;
          if (el._lastRepaintIndex !== this.repaintIndex) {
            this.itemsEl.removeChild(el);
            el._lastRepaintIndex = null;
          }
          el = next;
        }
        $(this.scrollerContentsEl).css({
          height: this.offsets.length * LINE_HEIGHT
        });
        $(this.itemsEl).show();
        this.scrollOffset = offset;
        if (!noStorePosition) {
          return this.storeScrollPosition();
        }
      },
      setTreeData: function(data) {
        var i, line, _i, _len, _ref2;
        this.containerHeight = this.el.offsetHeight;
        this.selectedIndex = null;
        this.lines = [];
        this._parseData(data);
        this.setDirty();
        _ref2 = this.lines;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          line = _ref2[i];
          if (line.autofold) {
            this.foldAt(i, true);
          }
        }
        this._doCleanDOM = true;
        if (data.length) {
          return this.trigger('load');
        } else {
          return this.scrollTo(0);
        }
      }
    });
    return module.exports = TreeOutline;
  });

}).call(this);
